{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introdu\u00e7\u00e3o","text":"<p>A motiva\u00e7\u00e3o inicial desse projeto \u00e9 gerar recursos automatizados o suficiente para subir uma infraestrutura com Kubernetes pronto para uso, de forma agn\u00f3stica de nuvem (podendo usar este mesmo projeto para deployar o cluster K8S em qualquer das clouds mais comuns), ou at\u00e9 mesmo agn\u00f3stica de infra (senvindo tamb\u00e9m para este deploy em ambiente On Premise).</p> <p>Acessar o projeto</p>"},{"location":"documentacao_env/documentacao_env/","title":"Sobre esta documenta\u00e7\u00e3o","text":""},{"location":"documentacao_env/documentacao_env/#poetry","title":"Poetry","text":"<p>Est\u00e1 sendo utilizado o Poetry para criar uma env do Python apenas com os recursos necess\u00e1rios para o uso do mkdocs. Ap\u00f3s criar e acessar a pasta \"docs\".</p> <pre><code>poetry init -n --name=iac-para-kubernetes-doc\npoetry add mkdocs\npoetry add pymdown-extensions\npoetry add mkdocs-material\npoetry add Pygments\n</code></pre>"},{"location":"documentacao_env/documentacao_env/#mkdocs","title":"Mkdocs","text":"<p>O mkdocs foi escolhido para essa documenta\u00e7\u00e3o por ser de f\u00e1cil edi\u00e7\u00e3o, por j\u00e1 ser usado em muitos projetos grandes, portanto est\u00e1 se tornando um padr\u00e3o e pela possibilidade de utiliz\u00e1-lo no Github Pages.</p> <p>Para iniciar o mkdocs</p> <pre><code>mkdocs new .\n</code></pre> <p>Para deployar o mkdocs no Github Pages</p> <pre><code>mkdocs gh-deploy\n</code></pre>"},{"location":"documentacao_env/documentacao_env/#referencias","title":"Refer\u00eancias","text":"<p>Poetry:</p> <p>Gerenciando pacotes e ambientes com Poetry</p> <p>MkDocs:</p> <p>Documentado projetos com MkDocs</p>"},{"location":"provisionamento/ansible/","title":"Ansible","text":"<p>O Ansible ser\u00e1 utilizado para automatizar a instala\u00e7\u00e3o do Kubernetes, tanto em um cluster local, quanto em um remoto.</p>"},{"location":"provisionamento/ansible/#tree","title":"Tree","text":""},{"location":"provisionamento/ansible/#vars","title":"Vars","text":"<p>Contem vari\u00e1veis gerais, que pode ser utilizadas em qualquer m\u00f3dulo do Ansible</p>"},{"location":"provisionamento/ansible/#inventory","title":"Inventory","text":"<p>Na pasta inventory existe um arquivo onde s\u00e3o listadas as m\u00e1quinas que ser\u00e3o acessadas.</p> <p>S\u00e3o definidos tamb\u00e9m tr\u00eas grupos de m\u00e1quinas:</p> <ul> <li>Kubernetes: incluindo todos os n\u00f3s</li> <li>Control plane: n\u00f3s que rodar\u00e3o como control plane do Kubernetes</li> <li>Nodes: n\u00f3s que rodar\u00e3o como workers do kubernetes</li> </ul>"},{"location":"provisionamento/ansible/#documentar-sobre-inventario-dinamico","title":"DOCUMENTAR SOBRE INVENT\u00c1RIO DIN\u00c2MICO","text":""},{"location":"provisionamento/ansible/#roles","title":"Roles","text":"<p>Contem todas as fazes de instala\u00e7\u00f5es e configura\u00e7\u00f5es</p> commonskubernetescontainerdcontrol_planeconfig_nodesinstall_kubectl <p>\u00c9 aplicado a todos os n\u00f3s.</p> <ul> <li>Faz um apt update e um apt upgrade </li> <li>Instala os pacotes necess\u00e1rios</li> <li>Liga os m\u00f3dulos de kernel necess\u00e1rios</li> </ul> <p>\u00c9 aplicado a todos os n\u00f3s.</p> <p>Aplica as configura\u00e7\u00f5es necess\u00e1rias para a instala\u00e7\u00e3o do cluster Kubernetes</p> <ul> <li>Baixa as chaves e adiciona os reposit\u00f3rios do K8S</li> <li>Instala o Kubelet, Kubeadm e Kubectl</li> <li>Trava a vers\u00e3o destes componentes</li> <li>Reseta o kubeadm para evitar erro no momento da cria\u00e7\u00e3o do cluster</li> </ul> <p>\u00c9 aplicado a todos os n\u00f3s.</p> <p>Instala e configura componentes necess\u00e1rios para a utiliza\u00e7\u00e3o do containerd como CRI do Kubernetes</p> <ul> <li>Baixa a chave e adiciona o reposit\u00f3rio do containerd</li> <li>Instala pacote do containerd</li> <li>Edita o arquivo config.toml do containerd para que utilize o grupo systemdCgroup</li> <li>Reseta o servi\u00e7o do containerd</li> </ul> <p>\u00c9 aplicado apenas ao grupo control_plane</p> <p>Inicia o cluster kubernetes</p> <ul> <li>Utiliza o kubeadm init</li> <li>Copia o arquivo que origina o .kube/config</li> <li>Gera o comando para fazer um join de nodes ao cluster e salva em um dummy host</li> </ul> <p>\u00c9 aplicado apenas aos nodes</p> <p>Faz o join dos nodes ao cluster utilizando o comando gerado anteriormente pelo control plane</p> <p>\u00c9 aplicado a um control plane e n\u00e3o executa como sudo</p> <p>Faz instala\u00e7\u00f5es necess\u00e1rias via kubectl</p> <ul> <li>Faz kubectl apply do CNI Wavenet</li> </ul>"},{"location":"provisionamento/ansible/#playbooks","title":"Playbooks","text":"<p>Associa de forma ordenada as tasks que devem ser executadas com cada grupo de hosts.</p>"},{"location":"provisionamento/ansible/#teste","title":"Teste","text":"<p>Tentando usar um mesmo projeto para deployar tanto em nuvem quanto em m\u00e1quinas locais.</p> <p>Warning</p> <p>Ainda n\u00e3o sei a melhor forma de se fazer isso, seguindo boas pr\u00e1ticas. Mas essa foi a forma que consegui fazer. Pretendo, o mais breve, descobrir a forma certa de se fazer isso.</p> InventoryPlaybooks <p>Pasta inventory dividida em dois arquivos:</p> <ul> <li>rasp.yaml: refer\u00eancia \u00e0s m\u00e1quinas locais (Raspberries Pi)</li> <li>cloud.yaml: refer\u00eancia a m\u00e1quinas que ser\u00e3o geradas na AWS</li> </ul> <p>Na pasta playbooks existem duas pastas, cloud e rasp, cada uma contendo um arquivo de playbook e um ansible.cfg.</p> <p>Cada arquivo ansible.cfg faz refer\u00eancia a um inventory e cada playbook configura o nome de usu\u00e1rio linux de acordo com o conjunto de m\u00e1quinas a que se refere.</p>"},{"location":"provisionamento/ansible/#referencias","title":"Refer\u00eancias","text":"<p>Ansible:</p> <p>Descomplicando o Ansible Kubernetes com CRI-O - Subindo um cluster do zero</p> <p>30 Exemplos do comando sed</p> <p>Recarregando o invent\u00e1rio do Ansible durante a execu\u00e7\u00e3o</p>"},{"location":"provisionamento/terraform/","title":"Terraform","text":"<p>\u00c9 utilizado para construir o ambiente em nuvem em que o Kubernetes ser\u00e1 instalado.</p>"},{"location":"provisionamento/terraform/#aws","title":"AWS","text":""},{"location":"provisionamento/terraform/#tree","title":"Tree","text":""},{"location":"provisionamento/terraform/#terrafile","title":"Terrafile","text":"<p>No arquivo terrafile.tf temos as declara\u00e7\u00f5es dos m\u00f3dulos, como \"instancias_k8s\", \"security\" e \"network\", por exemplo.</p> <p>Em cada m\u00f3dulo \u00e9 declarado um source (path de onde se encontra este m\u00f3dulo) e suas respectivas vari\u00e1veis de ambiente.</p>"},{"location":"provisionamento/terraform/#provider","title":"Provider","text":"<p>Identifica o cloud provider utilizado, neste caso AWS, que recebe o argumento \"region\", declarado nas vari\u00e1veis gerais.</p>"},{"location":"provisionamento/terraform/#modulos","title":"Modulos","text":"intancias_k8snetworksecurity <p>Define as inst\u00e2ncias utilizadas para o cluster Kubernetes.</p> <p>Temos as defini\u00e7\u00f5es para inst\u00e2ncias control plane e inst\u00e2ncias nodes.</p> <p>Para cada uma destas, temos as seguintes defini\u00e7\u00f5es:</p> <ul> <li>N\u00famero de inst\u00e2ncias;</li> <li>Amazon Machine Image (AMI) para utilizar na inst\u00e2ncia;</li> <li>Tipo da inst\u00e2ncia (por exemplo, t2.medium);</li> <li>ID da subnet;</li> <li>Se a inst\u00e2ncia deve ter um IP p\u00fablico associado;</li> <li>Security Group associado;</li> <li>\u00c9 passado um script bash para alterar o nome do host ao se criar a inst\u00e2ncia;</li> <li>Nome da chave criptogr\u00e1fica anteriormente gerada para a comunica\u00e7\u00e3o SSH;</li> <li>Tag \"Name\", para que na lista de inst\u00e2ncias na interface seja mostrado o hostname da inst\u00e2ncia na coluna de nome.</li> </ul>"},{"location":"provisionamento/terraform/#referencias","title":"Refer\u00eancias","text":"<p>Terraform Essentials</p>"},{"location":"seguranca/chaves_ssh/","title":"Gerando par de chaves para acesso ssh","text":"<p>Para facilitar o acesso via SSH \u00e0 uma m\u00e1quina remota, \u00e9 altamente recomendado o uso de um par de chaves criptogr\u00e1ficas. Tanto por motivos de seguran\u00e7a, quanto de praticidade, pois elimina a necessidade de inser\u00e7\u00e3o de senha a cada acesso \u00e0 m\u00e1quina.</p>"},{"location":"seguranca/chaves_ssh/#gerando-as-chaves-atraves-do-ssh-keygen","title":"Gerando as chaves atrav\u00e9s do ssh-keygen","text":"<p>Este processo gera duas chaves, uma privada, que deve ser mantida na m\u00e1quina onde se desenvolve, e uma p\u00fablica que deve ser alocada nas m\u00e1quinas remotas. No caso de m\u00e1quinas locais, pode-se enviar a chave p\u00fablica para cada m\u00e1quina. M\u00e1quinas geradas em nuvem, faremos o processo mais automatizado, a chave ser\u00e1 enserida no host durante sua cria\u00e7\u00e3o via Terraform.</p> <pre><code>ssh-keygen -f rasp_key # -f especifica o nome do arquivo, que por padr\u00e3o \u00e9 id_rsa\nssh-copy-id -i rasp_key.pub kluster@192.168.2.120 # deve-se especificar o nome da chave e o host pra onde se quer envi\u00e1-la\nssh-add rasp_key # adicionando a chave rasp_key a um agent ssh para n\u00e3o ser necess\u00e1rio passar o path da chave como argumento para o acesso \u00e0 m\u00e1quina remota\n</code></pre>"},{"location":"seguranca/chaves_ssh/#referencias","title":"Refer\u00eancias","text":"<p>Chaves ssh:</p> <p>Descomplicando o Ansible \u2192 Day-1 \u2192 Setup inicial e nosso primeiro ping!</p>"}]}